(ns ^{:doc "Core Midje functions that process expects and report on their results."} 
  midje.unprocessed 
  (:use clojure.test
        [midje.ideas.background :only [background-fakes]]
        [midje.checkers.extended-equality :only [extended-=]]
        [midje.checkers.chatty :only [chatty-checker?]]
        [midje.error-handling.exceptions :only [captured-throwable]]
        midje.internal-ideas.fakes
        midje.ideas.reporting.report
        midje.util.laziness
        [midje.util.namespace :only [immigrate]]
        [midje.util.ecosystem :only [line-separator]]
        [utilize.seq :only [find-first]]))
(immigrate 'midje.checkers)


;; Formula Reporting - 
;; one report for every batch of trials generated by a single formula run

(def ^{:private true} formula-reports (atom []))

(defn ^{:private true} report-formula [report-map]
  (when-not (= :pass (:type report-map))
    (note-failure-in-fact))
  (swap! formula-reports conj report-map))

(defn ^{:private true} report-formula-conclusion [_]
  (if-let [failure (find-first #(not= :pass (:type %)) (reverse @formula-reports))]
    (report failure)
    (report {:type :pass}) )
  (reset! formula-reports []))


;; Depending on the result, report appropriately

(letfn [(fail [type actual call]
          {:type type
           :description (:description call)
           :binding-note (:binding-note call)
           :position (:position call)
           :actual actual
           :expected (:expected-result-text-for-failures call)})

  (check-result-positive [report-fn actual call]
    (cond  (extended-= actual (:expected-result call))
           (report-fn {:type :pass})

           (fn? (:expected-result call))
           (report-fn (merge (fail :mock-expected-result-functional-failure
                                   actual call)
                             ;; TODO: It is very lame that the
                             ;; result-function has to be called again to
                             ;; retrieve information that extended-=
                             ;; knows and threw away.
                              (or ( (:expected-result call) actual)
                                  {})))
            
           :else
           (report-fn (assoc (fail :mock-expected-result-failure actual call)
                        :expected (:expected-result call)))))
  
  (check-result-negated [report-fn actual call]
    (cond (not (extended-= actual (:expected-result call)))
      (report-fn {:type :pass})

      (fn? (:expected-result call))
      (report-fn (fail :mock-actual-inappropriately-matches-checker actual call))

      :else
      (report-fn (fail :mock-expected-result-inappropriately-matched actual call))))]


  (defmulti ^{:private true} check-result (fn [_actual_ call]
                                            [(:desired-check call) (or (:formula call) :fact)] ))

  ;; Methods for processing =>/=not=> facts

  (defmethod check-result [:check-match :fact] [actual call]
    (check-result-positive report actual call))

  (defmethod check-result [:check-negated-match :fact] [actual call]
    (check-result-negated report actual call))


  ;; Methods for processing formulas

  (defmethod check-result [:check-match :formula-in-progress] [actual call]
    (check-result-positive report-formula actual call))

  (defmethod check-result [:check-negated-match :formula-in-progress] [actual call]
    (check-result-negated report-formula actual call))

  (defmethod check-result [:check-match :formula-conclude] [actual call]
    (check-result-positive report-formula-conclusion actual call))

  (defmethod check-result [:check-negated-match :formula-conclude] [actual call]
    (check-result-negated report-formula-conclusion actual call)))

(defn expect*
  "The core function in unprocessed Midje. Takes a map describing a
  call and a list of maps, each of which describes a secondary call
  the first call is supposed to make. See the documentation at
  http://github.com/marick/Midje."
  [unprocessed-check local-fakes]
  (with-installed-fakes (concat (reverse (filter :data-fake (background-fakes))) local-fakes)
    (let [code-under-test-result (try
                                   (eagerly
                                     ((:function-under-test unprocessed-check)))
                                  (catch Throwable ex
                                    (captured-throwable ex)))]
      (report-incorrect-call-counts local-fakes)
      (check-result code-under-test-result unprocessed-check)
      :irrelevant-return-value)))
